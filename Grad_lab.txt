#include <msp430.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdio.h>
#include <strings.h>

#define a BIT0
#define b BIT1
#define c BIT2
#define d BIT4
#define e BIT5
#define f BIT6
#define g BIT7


unsigned int display[10]={a+b+c+d+e+f, b+c, a+b+g+e+d, a+b+g+c+d, f+g+b+c, a+f+g+c+d, a+f+e+d+c+g,
                              a+b+c, a+b+c+d+e+f+g, a+b+c+d+f+g};

void ConfigClock(void);
void initTimer_A(void);
void bcdMSBDisplay(int i);
void bcdLSBDisplay(int i);

int miliseconds;
volatile double distance;
int distance1;
long sensor;
int distance_int;
double temp_float;

void main(){
    volatile float dis;

    WDTCTL = WDTPW + WDTHOLD;                 // Stop Watch dog timer

    P1IFG &= 0x00;                            // Clear all interrupt flags
    P1DIR |= 0x01;                            // P1.0 as output for LED
    P1OUT &= ~0x01;                           // turn LED off

    P2DIR = a+b+c+d;      // Setting pins of Port 2 as output
  //  P2SEL &= ~0xC0;             // Selecting mode of Port 2, setting XIN and XOUT as GPIO

    _BIS_SR(GIE);                       // global interrupt enable


    ConfigClock();
    initTimer_A();

   //Set up Timers- Timer A0
   TACCR0 = 1000-1;
   //Start Timer, Compare value for Up Mode to get 1ms delay per loop
   /*Total count = TACCR0 + 1. Hence we need to subtract 1.
   1000 ticks @ 1MHz will yield a delay of 1ms.*/

   while(1)
   {

      //P2OUT = 0x01;
      P1IE &= ~0x01;                    // disable interrupt
      P1DIR |= 0x02;                    // trigger pin as output
      P1OUT |= 0x02;                    // generate pulse
      __delay_cycles(10);               // for 10us
      P1OUT &= ~0x02;                   // stop pulse
      P1DIR &= ~0x04;                   // make pin P1.2 input (ECHO)
          P1IFG = 0x00;                 // clear flag just in case anything happened before
      P1IE |= 0x04;                     // enable interrupt on ECHO pin
      P1IES &= ~0x04;                   // rising edge on ECHO pin

      __delay_cycles(30000);            // delay for 30ms (after this time echo times out if there is no object detected)
      distance = sensor/5800;  // converting ECHO length into cm

    //  distance1= sensor/58;


      if(distance_int > 1) P1OUT |= 0x01;  //turning LED on if distance is less than 20cm and if distance isn't 0.
      else P1OUT &= ~0x01;

      distance_int = floor(distance);
      bcdMSBDisplay(distance_int);

      temp_float = distance - distance_int;

      int decimal = temp_float *10;
      void bcdLSBDisplay();

   }
}

#pragma vector=PORT1_VECTOR
__interrupt void Port_1(void)
{
    if(P1IFG&0x04)  //is there interrupt pending?
        {
          if(!(P1IES&0x04)) // is this the rising edge?
          {
            TACTL|=TACLR;   // clears timer A
            miliseconds = 0;
            P1IES |= 0x04;  //falling edge
          }
          else
          {
            sensor = (long)miliseconds*1000 + (long)TAR;    //calculating ECHO length

          }
    P1IFG &= ~0x04;             //clear flag
    }
}

#pragma vector=TIMER0_A0_VECTOR
__interrupt void Timer_A (void)
{
  miliseconds++;
}

void ConfigClock(void) {
    //Set MCLK = SMCLK = 1MHz
        BCSCTL1 = CALBC1_1MHZ;
        DCOCTL = CALDCO_1MHZ;
}

void initTimer_A(void) {
    //Timer Configuration
    TACCR0 = 0; //Initially, Stop the Timer
    TACCTL0 |= CCIE; //Enable interrupt for CCR0.
    TACTL = TASSEL_2 + ID_0 + MC_1; //Select SMCLK, SMCLK/1 , Up Mode
}

void bcdMSBDisplay(int i){

    switch(i)
    {
    case 0:
        P2OUT &= 0x00;
        break;
    case 1:
        P2OUT &= 0x01;
        break;
    case 3:
        P2OUT &= 0x02;
        break;
    case 4:
        P2OUT &= 0x04;
        break;
    }
}

void bcdLSBDisplay(int i){

    switch(i)
    {
    case 0:
        P1OUT &= 0x00;
        break;
    case 1:
        P1OUT &= 0x01;
        break;
    case 3:
        P1OUT &= 0x02;
        break;
    case 4:
        P1OUT &= 0x03;
        break;
    case 5:
        P1OUT &= 0x04;
        break;
    case 6:
        P1OUT &= 0x05;
        break;
    case 7:
        P1OUT &= 0x06;
        break;
    case 8:
        P1OUT &= 0x07;
        break;
    case 9:
        P1OUT &= 0x08;
        break;
    }
}
